<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>学术讲座# 中国人民大学经济学院江艇：因果推断Ⅰ</title>
      <link href="/2022/09/12/jiangting1/"/>
      <url>/2022/09/12/jiangting1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>&nbsp;<br>&nbsp;<br>&nbsp;</p><p><strong>因果推断</strong></p><ul><li>因果识别+统计推断</li><li>因果识别（causal identification）：如果拥有总体，能否确定总体因果关系</li><li>统计推断（statistical inference）：如何从样本数据获取总体因果关系信息，实际是一种相关性事实</li><li>识别假设，实际就是对$D$和$\epsilon$的关系作出表述，但这种过程是无法从理论上验证的</li><li>随机实验：研究者主动介入了数据生成过程，以确保干净的干预效应生成过程。在平均意义上，只有$D$是两者之间唯一的系统性差别</li></ul><p>&nbsp;<br>&nbsp;<a id="more"></a><br>&nbsp;</p><h2 id="1"><a href="#1" class="headerlink" title="1"></a><strong>1</strong></h2><p><strong>1.1</strong> 因果效应的定义：干预与否、处理与否时，潜在结果之间的差值。潜在结果一定是同一个时间点上的结果</p><p><strong>1.2</strong> 潜在结果永远无法完全观测，除非存在平行宇宙</p><p><strong>1.3</strong> 通过识别假设可以进行“插值”，可以化“相关关系”识别场景为“因果关系”识别场景</p><p><strong>1.4</strong> 鲁宾因果模型（潜在因果框架），一套描述因果关系的新语言</p><p>&nbsp;</p><h2 id="2"><a href="#2" class="headerlink" title="2"></a><strong>2</strong></h2><p><strong>2.1</strong> 第一类识别假设：潜在结果均值独立于处理状态</p><p><strong>2.2</strong> 从干扰项中剥离出控制变量；或者寻找一个与干扰项不相关的工具变量</p><p><strong>2.3</strong> 第二类识别假设：潜在结果条件均值独立于处理状态</p><p><strong>2.4</strong> 好的控制变量：既影响$Y$，又影响$D$。其本身和干扰项是否相关是不重要的，不是研究者关注的中心</p><p><strong>2.5</strong> 一个好的因果推断研究往往只关注一个影响因素</p><p><strong>2.6</strong> 无需过渡阐释控制变量的系数</p><p>&nbsp;</p><h2 id="3"><a href="#3" class="headerlink" title="3"></a><strong>3</strong></h2><p><strong>3.1 </strong>鲁宾因果模型并未规定具体的函数形式</p><p><strong>3.2</strong> 但我们通常不用鲁宾因果模型语言设定假设</p><p>&nbsp;</p><h2 id="4"><a href="#4" class="headerlink" title="4"></a><strong>4</strong></h2><p><strong>4.1 </strong>选择性又称之为分配机制，每个个体如何接受处理，可以用倾向得分来表示</p><p><strong>4.2 </strong>建议现实使用IV、DID、RDD等识别方法时，称之为准实验</p><p>&nbsp;</p>]]></content>
      
      
      <categories>
          
          <category> 计量 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学术讲座 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学术讲座# 中国人民大学经济学院江艇：渐进DID的最新进展</title>
      <link href="/2022/08/24/DID1/"/>
      <url>/2022/08/24/DID1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>&nbsp;<br>&nbsp;<br>&nbsp;</p><p><strong>关于DID因果识别</strong></p><ul><li>Imbens: 任何的因果识别归根结底都是做<strong>差值</strong></li><li>传统$DID$最大的两类威胁是：①平行趋势不成立；②存在混淆政策</li><li>$DID$的重要前提是平行趋势，但这种前提实际并不能完全验证：事前平行并不意味着事后平行趋势，但事前不平行一定能验证平行趋势不成立</li><li>最经典的例子就是经济特区，深圳在改革开放前可能和中原地区的一个小村庄没有什么不同，但是即使深圳没有被划为经济特区，改革开放后其经济增长趋势也有可能因为地缘优势而呈现较快的增长趋势</li><li>两期的数据做$DID$会退化为$FD$，此时的截距项代表时间变化趋势</li><li>Good control: 既影响$y$，又影响$D \cdot T$</li><li>Bad control: 既影响$y$，又被$D \cdot T$影响</li><li>无法判断影响样本进入处理组的因素是否还影响其变化趋势</li><li>潜在结果：使用上标表示，想象中的结果</li><li>$ATT$：处理组接受处理后的平均处理效应</li><li>$D$实际可以理解为处理组的固定效应</li></ul><p>&nbsp;<br>&nbsp;<a id="more"></a><br>&nbsp;</p><h2 id="1-交错型DID-staggered-DID"><a href="#1-交错型DID-staggered-DID" class="headerlink" title="1. 交错型DID(staggered DID)"></a><strong>1. 交错型DID(staggered DID)</strong></h2><ul><li>没有办法构造$D \cdot T$，可以直接定义$D \cdot T$，表示接受处理的虚拟变量</li><li>干预事件的发生时间不一致，极可能意味着，事后趋势不一致。为此，应尽量控制影响$X_i$，避免控制既影响$y$，又被$D \cdot T$影响的$X_{it}$</li><li>为了能够控制$X_i$，需要将其乘以一个时间趋势项$t$，或者设置$X_i$与时间固定效应$\mu_t$的交互项</li><li>Goodman-Bacon定理：任何一个交错$DID$的双向固定效应模型都可以分解为$K^2$个传统双重差分估计结果的加权平均</li><li>导致偏误的原因在于：以晚处理组为处理组，以早处理组为对照组，此时双重差分估计中包含了一项$\Delta ATT$，即早处理组的政策效应存在明显的动态变化</li><li>交错$DID$估计出的$\beta$究竟意味着什么？由三部分构成：①方差加权的$ATT$；②方差加权的趋势差异；③$\Delta ATT$</li></ul><p>&nbsp;</p><h2 id="2-改进策略——基于事件研究法"><a href="#2-改进策略——基于事件研究法" class="headerlink" title="2. 改进策略——基于事件研究法"></a><strong>2. 改进策略</strong>——基于事件研究法</h2><p><strong>2.1 </strong>进行$bacondecommp$分解，观察以早处理组为控制组的系数和权重，判断其是否影响了最终系数的估计</p><p><strong>2.2</strong> 进行协变量的平衡性检验。在交错$DID$的情形下，平行趋势检验没办法做。干预时间的不一致，平衡性检验可作为一种替代手段。此做法的目的在于判断事前变量与干预处理进度之间的关系。进行匹配时，都可以以政策执行前某一期为准</p><p><strong>2.3</strong> 进一步，可以按照各组作为控制组的贡献作为权重，对事前变量与干预处理进度进行加权$OLS$</p><p><strong>2.4</strong> 进行$bacondecommp$分解，必须是平衡面板数据，所以要删除一些样本</p><p><strong>2.5</strong> 事件研究法：变日历时间为相对时间。按照相对时间进行校准，如果存在非常明显的趋势，则$\Delta ATT$一定会比较大，基准模型会存在低估偏误</p><p><strong>2.6</strong> 可以根据事件研究法的结果，将核心解释变量乘以一个$t-T^*$</p><p>&nbsp;</p><h2 id="3-改进策略——堆叠-DID-Stacked-DID"><a href="#3-改进策略——堆叠-DID-Stacked-DID" class="headerlink" title="3.改进策略——堆叠$DID$(Stacked $DID$)"></a><strong>3.改进策略</strong>——堆叠$DID$(Stacked $DID$)</h2><p><strong>3.1 </strong>假定存在K个处理时点，构造K个数据集。每个数据集中只保留可以为处理组服务的控制组，比如晚处理组和一直未处理的组。标准误需要聚类到数据集上面</p><p><strong>3.2</strong> 从构造上保证了早处理组不能作为控制组</p><p>&nbsp;</p><h2 id="4-改进策略——对事件研究法的反思，寻找干净的控制组"><a href="#4-改进策略——对事件研究法的反思，寻找干净的控制组" class="headerlink" title="4.改进策略——对事件研究法的反思，寻找干净的控制组"></a><strong>4.改进策略</strong>——对事件研究法的反思，寻找干净的控制组</h2><p><strong>4.1 </strong>仅不同时间队列样本的动态处理效应变化方式是一样的，事件研究法的估计才是有效的</p><p>&nbsp;</p>]]></content>
      
      
      <categories>
          
          <category> 计量 </category>
          
          <category> DID </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学术讲座 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2014到2021年:淘宝村分布散点图😲</title>
      <link href="/2022/02/12/taobao/"/>
      <url>/2022/02/12/taobao/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><p><img data-src="/figure/2014.svg" width="70%" height="70%" align="middle"></p><center>2014年的淘宝村分布</center><a id="more"></a><p><img data-src="/figure/2021.svg" width="70%" height="70%" align="middle"></p><center>2021年的淘宝村分布</center><h2 id="从最初3个增长至7023个"><a href="#从最初3个增长至7023个" class="headerlink" title="从最初3个增长至7023个"></a>从最初3个增长至7023个</h2><p>从2009年到2021年，中国淘宝村呈现裂变式的扩散增长，从最初3个增长至7023个，无论是数量规模，还是分布广度都经历了飞跃式的发展。从萌芽至发展阶段，“小农户连接大市场”的电商逻辑长期被认为是淘宝村的主要内涵。围绕这一内涵，市场、政策、技术、人才一度不断汇聚，为淘宝村发展创造了十余年的黄金机遇，形成了一场边缘人群连接现代网络、边缘地区接壤现代市场、边缘产品汇聚现代需求的“边缘革命”。然而，在经历十余年的飞速发展后，淘宝村开始面临红利期消失、消费升级、同质化竞争、规范治理等适应性挑战，转型变革已是必然选择。在这一过程中，过往遵循传统电商逻辑的淘宝村正经历蜕变。一方面，垂直电商、内容电商等多元化的销售互联网生态正加速形成；另一方面，由差异化、个性化、碎片化需求所驱动的产业数字化升级不断涌现。可以认为，以“消费互联网+产业互联网”为特征的产销全域数字化逻辑正在为淘宝村注入新的内涵，其核心不再是“连接大市场”，而是“洞悉大市场、细分小市场、塑造新市场”。这种内涵演进对淘宝村发展提出了更高的要求，即能否充分利用数字技术提高经营主体的市场洞察力，能否通过数据信息整合优化生产流程，能否基于数字供应链实现快速的市场反馈。在此意义上，新时代的淘宝村将不再是“逆边缘化”的地理名词，而是一类凭借数字技术突破分散决策、分散生产、分散经营劣势的组织指称。</p>]]></content>
      
      
      <categories>
          
          <category> 绘图 </category>
          
          <category> map&amp;sf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> R </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文献阅读# 政策转移中的政策再生产:影响因素与模式概化</title>
      <link href="/2020/06/08/paper1/"/>
      <url>/2020/06/08/paper1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>&nbsp;<br>&nbsp;<br>&nbsp;</p><h2 id="1-研究问题"><a href="#1-研究问题" class="headerlink" title="1. 研究问题"></a><strong>1. 研究问题</strong></h2><p>本文以江苏省12个地级市“河长制”政策转移案例(2006 — 2016)为研究对象,在识别政策转移案例中“复制”和“再生产”两种程度差异的基础上,应用定性比较分析(<code>QCA</code>)方法探索了资源禀赋、行政压力、政策需求、外部力量四大类因素对“河长制”转移程度的影响。研究发现“河长制”政策转移中的“政策再生产”的形成是多种因素组合作用的结果,而影响变量的组合并非一元,呈现多元化格局。通过<code>QCA</code>软件的数据梳理排序得出覆盖率最高的四种组合,在此基础上概化出政策转移中政策“再生产”的三种模式:资源主导型政策再生产,行政压力、资源、社会力量复合驱动型政策再生产,政府和智库合作型政策再生产。</p><p>&nbsp;</p><a id="more"></a><h2 id="2-问题的提出"><a href="#2-问题的提出" class="headerlink" title="2. 问题的提出"></a><strong>2. 问题的提出</strong></h2><p><strong>2.1 政策转移的必要性</strong></p><p>现实状况：政策供给不均衡、地方政策供给能力局限性、政策再生产本身具有“后发优势”的意味、地区间的合作与竞争</p><p>转移情形：政策转移并不意味着全盘复制，可分为“复制”和“再生产”两种形式</p><p>核心问题：什么因素能够促成政策“再生产”，政策“再生产”又体现出那些维度特征</p><p><strong>2.2 河长制的背景介绍</strong></p><p>河湖治理是跨界特性最典型的领域之一，涉及上下游、左右岸、不同行政区域和行业，呈现出高度的复杂性。河长制最早发轫于太湖蓝藻危机，2016年之前是一项地方政策，经政策扩散至多地。</p><p>现实调查显示河长制在江苏省内的扩散过程中呈现出“复制”和“再生产”的典型差异。</p><p>&nbsp;</p><h2 id="3-研究思路和方法"><a href="#3-研究思路和方法" class="headerlink" title="3. 研究思路和方法"></a><strong>3. 研究思路和方法</strong></h2><p><strong>3.1 QCA</strong></p><p>定性比较分析既是一种研究方法,也是一类分析技术的统称,由查尔斯·拉金(Charles Ragin)于<code>1987</code>年提出，适用于案例数量大于10小于60的研究。</p><p>其使用布尔代数和集合论的思想来进行中小数量的跨案例比较，从而处理多个原因和一个结果之间的因果关系。</p><p><strong>3.2 转移程度的刻画</strong></p><p>道洛维茨和马什最早借鉴rose（1993）的连续统来划分政策转移程度：复制、模仿、混合、启发。</p><p>本文简单划分为：“复制”和“再生产”</p><p><strong>3.3 解释变量的选择</strong></p><p>行政压力、资源禀赋、政策需求、外部力量</p><p>&nbsp;</p><h2 id="4-结论"><a href="#4-结论" class="headerlink" title="4. 结论"></a><strong>4. 结论</strong></h2><p>政策转移中政策“再生产”的三种模式:资源主导型政策再生产,行政压力、资源、社会力量复合驱动型政策再生产,政府和智库合作型政策再生产,三种模式命名体现出其主要影响因素。</p>]]></content>
      
      
      <categories>
          
          <category> 公共管理 </category>
          
          <category> 政策转移 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文献阅读 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文献阅读# the Effect of Microinsurance on Economic Activities: Evidence From a Randomized Field Experiment</title>
      <link href="/2020/06/06/paper2/"/>
      <url>/2020/06/06/paper2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>&nbsp;<br>&nbsp;<br>&nbsp;</p><p><strong>需要提前了解的生猪养殖知识背景</strong></p><ul><li>市场上常见的肉猪基本均为经过绝育的猪。一般而言，养殖户会在猪仔1个月大小的时候进行绝育，对公猪进行阉割，对母猪则切除卵巢。这种做法能够增加肉猪的成长速度，减少猪发情带来的成本，并减小猪肉的膻腥味、提升口感。</li><li>如果养殖户存养未绝育的种猪或母猪，其用途主要为繁育猪仔。</li><li>对于农村的小型散养户而言，每个村庄一般会有一个村兽医、或养殖技术联络员为其提供“猪的绝育”服务，村兽医、或养殖技术联络员基本 对应本文中的”Animal Husbandry Workers (AHW)”。</li></ul><p>&nbsp;<br>&nbsp;<br>&nbsp;</p><h2 id="1-研究问题"><a href="#1-研究问题" class="headerlink" title="1. 研究问题"></a><strong>1. 研究问题</strong></h2><p>本文旨在对“小额保险”（“普惠型保险”）对农户农业生产决策的作用进行因果识别。</p><p>具体而言，作者以“母猪保险”这一险种为例，以贵州省毕节市金沙县27个乡镇的480个村为实验场域，采用田野实验的方法，在中国人民财产保险股份有限公司（PCC）所推出的“母猪保险”产品基础上，结合金沙县“保险公司产推—&gt;畜牧局地推—&gt;养殖技术联络员村推”的保险推广模式，为村养殖技术联络员（AHW）随机分配“绩效激励”，进而设置了村级层面的处理组和控制组，基于“组别”设置了一个村级层面的外生变量，对“母猪保险”村庄覆盖差异与后期“母猪存栏量”之间的因果关系进行因果识别。</p><p>&nbsp;</p><a id="more"></a><h2 id="2-研究内容"><a href="#2-研究内容" class="headerlink" title="2. 研究内容"></a><strong>2. 研究内容</strong></h2><p><strong>2.1 设计田野实验并获得具有外生性的村庄“母猪保险”覆盖指标</strong></p><p>具体包含实验可行性分析、随机干预策略选择以及潜在作用机制及威胁分析三个部分，详见下图</p><p><img data-src="/paper_source/1.png" alt=""></p><p><strong>2.2 结合可获数据识别村庄“母猪保险”覆盖指标与“母猪存栏决策”之间的因果关系，并对识别效果进行有效性检验</strong></p><p>具体包含数据整合、特征性事实提炼、实证分析以及实验有效性分析四个部分，详见下图</p><p><img data-src="/paper_source/2.png" alt=""></p><p><strong>2.3 因果关系背后的作用机制、长期特征、溢出效应</strong></p><p>具体包含作用机制检验、长期效应及溢出效应分析，详见下图</p><p><img data-src="/paper_source/3.png" alt=""></p><p>&nbsp;</p><h2 id="3-研究思路"><a href="#3-研究思路" class="headerlink" title="3. 研究思路"></a><strong>3. 研究思路</strong></h2><p>文章研究思路如下图所示</p><p><img data-src="/paper_source/Diagram1.png" alt=""></p><p>&nbsp;</p><h2 id="4-研究方法"><a href="#4-研究方法" class="headerlink" title="4. 研究方法"></a><strong>4. 研究方法</strong></h2><p><strong>4.1 田野实验法：</strong>文章采用田野实验的方法产生了一个外生的随机干预效果，即养殖技术联络员（AHW）“绩效激励”差异引致的“母猪保险”村庄覆盖差异。</p><p><strong>4.2 统计分析与计量经济模型方法：</strong>文章进一步整合了地方畜牧局统计数据、中国农业普查数据，并以衡量“绩效激励”差异的变量LIG与HIG为工具变量，识别了村庄“母猪保险”覆盖指标与后期“母猪存栏量”之间的因果关系。</p><p>&nbsp;</p><h2 id="5-评述以及改进建议"><a href="#5-评述以及改进建议" class="headerlink" title="5. 评述以及改进建议"></a><strong>5. 评述以及改进建议</strong></h2><p><strong>5.1 评述</strong></p><p><strong>5.1.1</strong> 文章采用田野实验的方法，结合金沙县“保险公司产推—&gt;畜牧局地推—&gt;养殖技术联络员村推”保险推广模式，以及该地村庄间交通不便等现实特征，通过为村养殖技术联络员（AHW）随机分配“绩效激励”精妙地设置了外生随机干预，并以其作为投保“母猪保险”头数的工具变量，整合多方数据，识别了投保“母猪保险”与后期“母猪存栏量”之间的因果关系，并进行了有效性分析，并利用2008年南方雪灾造成母猪死亡数进行了机制分析。最终验证了“小额保险”对农户农业生产决策的作用。</p><p><strong>5.1.2</strong> 一方面，随机分配“绩效激励”的设置十分巧妙，其外生性以及与村庄总体投保数的相关性都可以得到充分的事实支撑。此外，作者以2008年南方雪灾造成的母猪死亡数作为“村庄发生‘母猪保险’赔付”的情景代理变量，验证了信任机制的重要性。</p><p><strong>5.1.3</strong> 另一方面，随机分配“绩效激励”的设置也可能面临异质性问题，村养殖技术联络员（AHW）个体特征的不同可能会影响其推广保险的绩效；此外，村庄的某些特征的差异也可能引起异质性，比如，人均受教育程度高的村庄可能更容易理解“母猪保险”的保险机制，进而体现出更高的投保率；最后，利用2008年南方雪灾造成的母猪死亡数进行机制分析的做法有些许勉强，或许可以直接从PCC获取相关赔付数据进行机制分析。</p><p><strong>5.2 改进建议</strong></p><p><strong>5.2.1</strong> 文章声明测度了村养殖技术联络员（AHW）的人口统计学变量，可依据这些变量进行异质性分析，因为AHW个人的某些特质，比如责任感、受教育程度可能会影响其推广保险的努力程度抑或有效程度。因此，可设置AWH特征变量与低“绩效激励”组（LIG）、高“绩效激励”组（HIG）的交互项，考察由AHW特征引起的“母猪保险”对“母猪存栏决策”的作用异质性。</p><p><strong>5.2.2</strong> 文章获得了村级层面的特征变量，却仅在所有模型中加入了乡镇（town）层面的哑变量，在模型中控制村庄特征变量比如村庄农户数、人均受教育程度等可能更有意义。再者，村庄的某些特征的差异也可能引起异质性，可设置村庄特征变量与低“绩效激励”组（LIG）、高“绩效激励”组（HIG）的交互项，考察由村庄特征引起的“母猪保险”对“母猪存栏决策”的作用异质性。</p><p><strong>5.2.3</strong> 文章认为2008年雪灾造成的母猪死亡数较多的村庄，可能发生了实际的“母猪保险”赔付，进而为村民提供了一种情景互动，提高了村民对保险机构的信任，这一机制仅为猜测。作者既然声明可从PCC获得保单，那么赔付数据也应该能够获取，应该基于真实的赔付数据进行机制检验。</p>]]></content>
      
      
      <categories>
          
          <category> 实验经济学 </category>
          
          <category> 保险 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文献阅读 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字体和公式的Display</title>
      <link href="/2020/05/30/testof_mathequation_fontface/"/>
      <url>/2020/05/30/testof_mathequation_fontface/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><hr><font face="Times New Roman"><p style="text-align:justify"><b>“Evaluating the employment impact of a mandatory job search program”</b></p></font><br><br><font face="Times New Roman"><p style="text-align:justify"><b>What treatment do the authors evaluate?</b></p></font><br><a id="more"></a> <font face="Tex Gyre Pagella"><p style="text-align:justify"><b>Answer: </b>In the parametric methods, the common trend assumption is: $$\begin{array}{l} f^{-1}\left[E\left(Y_{i t}^{0} | X, N D=1, t=1\right)\right]-f^{-1}\left[E\left(Y_{i t}^{0} | X, N D=1, t=0\right)\right] \\ =f^{-1}\left[E\left(Y_{i t}^{0} | X, N D=0, t=1\right)\right]-f^{-1}\left[E\left(Y_{i t}^{0} | X, N D=0, t=0\right)\right] \end{array}$$ In the non-parametric methods, the common trend assumption is: $$\begin{array}{l} E\left(Y_{i t}^{0} | P_{E X}, P_{t X}, N D=1, t=1\right)-E\left(Y_{i t}^{0} | P_{E X}, P_{t X}, N D=1, t=0\right) \\ =E\left(Y_{i t}^{0} | P_{E X}, P_{t X}, N D=0, t=1\right)-E\left(Y_{i t}^{0} | P_{E X}, P_{t X}, N D=0, t=0\right) \end{array}$$</p></font>]]></content>
      
      
      <categories>
          
          <category> 调试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog_test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>画一幅我农所在地的道路图</title>
      <link href="/2020/05/29/yanglingmap/"/>
      <url>/2020/05/29/yanglingmap/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><p><img data-src="/figure/yanglingroad.png" width="80%" height="80%" align="middle" style="display:block;margin:auto"></p><center>上图即为最终效果</center><h2 id="一些必备的工具"><a href="#一些必备的工具" class="headerlink" title="一些必备的工具"></a>一些必备的工具</h2><p>一张json格式的我农地图，或者杨陵地图,可从<a href="https://raw.githubusercontent.com/QGQ931001/git-tutorial/master/yangling_map/yangling.json" target="_blank" rel="noopener">我的github仓库下载</a></p><pre class="line-numbers language-lang-r"><code class="language-lang-r">download.file("https://raw.githubusercontent.com/QGQ931001/git-tutorial/master/yangling_map/yangling.json", destfile = "~/文档/yangling.json" )<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><a id="more"></a><h2 id="绘制路网地图"><a href="#绘制路网地图" class="headerlink" title="绘制路网地图"></a>绘制路网地图</h2><p>导入以下R 包：</p><pre class="line-numbers language-lang-r"><code class="language-lang-r">library(osmdata)library(dodgr)library(tidyverse)library(sf)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>读入杨陵区的数据：</p><pre class="line-numbers language-lang-r"><code class="language-lang-r">yl <- read_sf("~/文档/yangling.json") %>%  st_make_valid()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>获取杨陵区的经纬度范围:</p><pre class="line-numbers language-lang-r"><code class="language-lang-r">st_bbox(yl) %>%  matrix(nrow = 2,         dimnames = list(c("x", "y"),                         c("min", "max"))) -> eboxebox<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>#&gt;         min       max#&gt; x 107.94598 108.13869#&gt; y  34.22145  34.33377</code></pre><p>提取杨陵区的街道路线：</p><pre class="line-numbers language-lang-r"><code class="language-lang-r">sraw <- dodgr_streetnet(ebox)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>把数据保存为<strong>rds</strong>:</p><pre class="line-numbers language-lang-r"><code class="language-lang-r">sraw %>%  write_rds('sraw.rds')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>提取<strong>ebox</strong>和<strong>yl</strong>相交的区域：</p><pre class="line-numbers language-lang-r"><code class="language-lang-r">streets <- sraw %>%  st_make_valid() %>%  st_intersection(yl)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>然后绘图：</p><pre class="line-numbers language-lang-r"><code class="language-lang-r">ggplot() +  geom_sf(data = streets, show.legend = F, size = 0.2 ,color = "#DDE080" ) +  theme_ipsum(base_family = "Times New Roman") +  theme(panel.grid.major = element_blank(),          panel.grid.minor = element_blank(),          axis.text.x = element_blank(),          axis.text.y = element_blank(),          axis.title.x = element_blank(),          axis.title.y = element_blank(),          plot.background = element_rect(fill = "#140035",                                         color = "#140035"),          panel.background = element_rect(fill = "#140035",                                          color = "#140035")) +    labs(y = "")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 绘图 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> R </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>🙃大城市人口增长速度🔦</title>
      <link href="/2020/05/27/bubblemap/"/>
      <url>/2020/05/27/bubblemap/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><p><img data-src="/figure/bubblemap.png" width="80%" height="80%" align="middle"></p><center>上图即为最终效果</center><h2 id="下载数据"><a href="#下载数据" class="headerlink" title="下载数据"></a>下载数据</h2><p>将代码中的<strong><code>~/文档/</code></strong>更换为要保存的目录。</p><pre class="line-numbers language-lang-r"><code class="language-lang-r">download.file("https://raw.githubusercontent.com/QGQ931001/git-tutorial/master/bigcity/data-bKvwd.csv", destfile = "~/文档/data-bKvwd.csv" )download.file("https://raw.githubusercontent.com/QGQ931001/git-tutorial/master/bigcity/world.geo.json", destfile = "~/文档/world.geo.json" )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="加载R包"><a href="#加载R包" class="headerlink" title="加载R包"></a>加载R包</h2><p>需要的R包如下所示。</p><pre class="line-numbers language-lang-r"><code class="language-lang-r">library(sf)library(readr)library(tidyverse)library(hrbrthemes)library(ggtext)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><a id="more"></a><h2 id="读取各大城市人口数据并计算年平均人口增长率"><a href="#读取各大城市人口数据并计算年平均人口增长率" class="headerlink" title="读取各大城市人口数据并计算年平均人口增长率"></a>读取各大城市人口数据并计算年平均人口增长率</h2><p><code>worldmap</code>为<code>josn</code>格式的地图数据，<code>st_transform</code>为进行投影坐标变换的函数。</p><pre class="line-numbers language-lang-r"><code class="language-lang-r">worldmap <- read_sf('/home/qgq/文档/world.geo.json') %>%  st_transform(crs = 4326)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol><li><code>data-bKvwd</code>包含了世界多个城市的经纬度信息以及多年份的人口数据。</li><li><code>dplyr::select</code>函数主要用于筛选<code>data-bKvwd</code>中的<strong>4</strong>个关键变量，包含经纬度(Lon, Lat)，以及<strong>2000</strong>年和<strong>2016</strong>年的人口数据。</li><li><code>st_as_sf</code>是<code>sf</code>包中的函数，其将外来对象转换为<code>sf</code>对象，最终数据存储为<code>con_df</code>。</li><li><code>con_df$growth.rate</code>表示在<code>con_df</code>数据框^[可以通过<code>class(con_df)</code>查看<code>con_df</code>属于哪些类]中添加一个<code>growth.rate</code>变量，也可以进行对数增长率的计算。</li></ol><pre class="line-numbers language-lang-r"><code class="language-lang-r">read_csv('~/文档/data-bKvwd.csv') %>%  dplyr::select(Lat, Lon, `2000`,`2016`) %>%  st_as_sf(coords = c("Lon", "Lat"), crs = 4326) -> con_dfcon_df$growth.rate <- (as.numeric(con_df$`2016`)-as.numeric(con_df$`2000`))/as.numeric(con_df$`2000`)/17con_df$log.growth.rate <- log(as.numeric(con_df$`2016`)/as.numeric(con_df$`2000`))/17<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="对数据进行离散化处理"><a href="#对数据进行离散化处理" class="headerlink" title="对数据进行离散化处理"></a>对数据进行离散化处理</h2><p>连续的数据虽然包含更多信息，但是糅合一些离散化的策略，使用颜色或其它图形属性表征，能呈现出更直观的信息。<br>使用<code>mutate</code>函数将<code>growth.rate</code>离散化为<code>interval</code>。</p><pre class="line-numbers language-lang-r"><code class="language-lang-r">con_df <- con_df %>% mutate(    interval = case_when(      growth.rate < 0 ~ "负增长",      growth.rate >= 0 & growth.rate < 0.025 ~ "0～2.5%",      growth.rate >= 0.025 & growth.rate < 0.05 ~ "2.5%～5%",      growth.rate >= 0.05  ~ "5%以上"    )  )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>与此同时，计算出<code>growth.rate</code>的最大值用于辅助分段。</p><pre class="line-numbers language-lang-r"><code class="language-lang-r">max.gr <- as.numeric(  max(con_df$growth.rate,na.rm = T))  #>求growth.rate的最大值mybreaks <- c(0, 0.025, 0.05,max.gr) #>进行分段<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="绘图"><a href="#绘图" class="headerlink" title="绘图"></a>绘图</h2><p>代码如下，图见上文。</p><pre class="line-numbers language-lang-r"><code class="language-lang-r">ggplot(worldmap) +  geom_sf(size = 0.1, color = "#708090", fill = "grey",alpha=0.05) +  geom_sf(data = con_df,  aes(size = abs(growth.rate),                              color = interval,                              alpha = abs(growth.rate))) +  scale_size_continuous(name = "Average Growth Rate",                        range = c(2,2.41*4),                        breaks = mybreaks)  +  scale_alpha_continuous(name = "Average Growth Rate",                         range = c(0.4,0.7),                         breaks = mybreaks) +  scale_color_manual(values = c("#D9EF8B", "#A6D96A", "#66BD63","#D73027")) +  coord_sf(crs = "+proj=eck4")+  theme_minimal(base_family = "Roboto") +  theme(    axis.text = element_blank(),    axis.title = element_blank(),    panel.grid = element_blank(),    legend.position = "none",    plot.caption = element_text(color = "#708090", face = "italic",family = "Times New Roman",size = 11,hjust = 0.95),    plot.title = element_text(color = "#708090",family = "Times New Roman", size = 19))+  labs(title = "How fast do big cities grow?",       subtitle = "<b style='color:#D73027'>Negative Growth</b> / <b style='color:#D9EF8B'>0~2.5%</b> /       <b style='color:#A6D96A'>2.5%~5%</b> / <b style='color:#66BD63'>5% Plus</b>",       caption = "Data Source: How fast do big cities grow?")+  theme(plot.subtitle = element_markdown(lineheight = 1.1))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 绘图 </category>
          
          <category> map&amp;sf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> R </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>R数据科学——ggplot2笔记（1）</title>
      <link href="/2020/05/26/r_for_data_science/"/>
      <url>/2020/05/26/r_for_data_science/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="一个说明"><a href="#一个说明" class="headerlink" title="一个说明"></a>一个说明</h2><p><code>ggplot2::ggplot()</code>指使用<a href="https://ggplot2.tidyverse.org/" target="_blank" rel="noopener"><strong>ggplot2</strong></a>包中的<code>ggplot</code>函数，<code>::</code>表示快速调用某个包里的函数。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>使用<code>ggplot2</code>包中的<code>mpg</code>数据框，这份数据是一份汽车资料：</p><pre class="line-numbers language-lang-r"><code class="language-lang-r">knitr::kable(head(ggplot2::mpg, 10))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><div class="table-container"><table><thead><tr><th style="text-align:left">manufacturer</th><th style="text-align:left">model</th><th style="text-align:left">displ</th><th style="text-align:right">year</th><th style="text-align:right">cyl</th><th style="text-align:left">trans</th><th style="text-align:left">drv</th><th style="text-align:right">cty</th><th style="text-align:right">hwy</th><th style="text-align:left">fl</th><th style="text-align:left">class</th></tr></thead><tbody><tr><td style="text-align:left">audi</td><td style="text-align:left">a4</td><td style="text-align:left">1.8</td><td style="text-align:right">1999</td><td style="text-align:right">4</td><td style="text-align:left">auto(l5)</td><td style="text-align:left">f</td><td style="text-align:right">18</td><td style="text-align:right">29</td><td style="text-align:left">p</td><td style="text-align:left">compact</td></tr><tr><td style="text-align:left">audi</td><td style="text-align:left">a4</td><td style="text-align:left">1.8</td><td style="text-align:right">1999</td><td style="text-align:right">4</td><td style="text-align:left">manual(m5)</td><td style="text-align:left">f</td><td style="text-align:right">21</td><td style="text-align:right">29</td><td style="text-align:left">p</td><td style="text-align:left">compact</td></tr><tr><td style="text-align:left">audi</td><td style="text-align:left">a4</td><td style="text-align:left">2.0</td><td style="text-align:right">2008</td><td style="text-align:right">4</td><td style="text-align:left">manual(m6)</td><td style="text-align:left">f</td><td style="text-align:right">20</td><td style="text-align:right">31</td><td style="text-align:left">p</td><td style="text-align:left">compact</td></tr><tr><td style="text-align:left">audi</td><td style="text-align:left">a4</td><td style="text-align:left">2.0</td><td style="text-align:right">2008</td><td style="text-align:right">4</td><td style="text-align:left">auto(av)</td><td style="text-align:left">f</td><td style="text-align:right">21</td><td style="text-align:right">30</td><td style="text-align:left">p</td><td style="text-align:left">compact</td></tr><tr><td style="text-align:left">audi</td><td style="text-align:left">a4</td><td style="text-align:left">2.8</td><td style="text-align:right">1999</td><td style="text-align:right">6</td><td style="text-align:left">auto(l5)</td><td style="text-align:left">f</td><td style="text-align:right">16</td><td style="text-align:right">26</td><td style="text-align:left">p</td><td style="text-align:left">compact</td></tr><tr><td style="text-align:left">audi</td><td style="text-align:left">a4</td><td style="text-align:left">2.8</td><td style="text-align:right">1999</td><td style="text-align:right">6</td><td style="text-align:left">manual(m5)</td><td style="text-align:left">f</td><td style="text-align:right">18</td><td style="text-align:right">26</td><td style="text-align:left">p</td><td style="text-align:left">compact</td></tr><tr><td style="text-align:left">audi</td><td style="text-align:left">a4</td><td style="text-align:left">3.1</td><td style="text-align:right">2008</td><td style="text-align:right">6</td><td style="text-align:left">auto(av)</td><td style="text-align:left">f</td><td style="text-align:right">18</td><td style="text-align:right">27</td><td style="text-align:left">p</td><td style="text-align:left">compact</td></tr><tr><td style="text-align:left">audi</td><td style="text-align:left">a4 quattro</td><td style="text-align:left">1.8</td><td style="text-align:right">1999</td><td style="text-align:right">4</td><td style="text-align:left">manual(m5)</td><td style="text-align:left">4</td><td style="text-align:right">18</td><td style="text-align:right">26</td><td style="text-align:left">p</td><td style="text-align:left">compact</td></tr><tr><td style="text-align:left">audi</td><td style="text-align:left">a4 quattro</td><td style="text-align:left">1.8</td><td style="text-align:right">1999</td><td style="text-align:right">4</td><td style="text-align:left">auto(l5)</td><td style="text-align:left">4</td><td style="text-align:right">16</td><td style="text-align:right">25</td><td style="text-align:left">p</td><td style="text-align:left">compact</td></tr><tr><td style="text-align:left">audi</td><td style="text-align:left">a4 quattro</td><td style="text-align:left">2.0</td><td style="text-align:right">2008</td><td style="text-align:right">4</td><td style="text-align:left">manual(m6)</td><td style="text-align:left">4</td><td style="text-align:right">20</td><td style="text-align:right">28</td><td style="text-align:left">p</td><td style="text-align:left">compact</td></tr></tbody></table></div><a id="more"></a><p>创建<code>ggplot2</code>图形,散点图：</p><pre class="line-numbers language-lang-r"><code class="language-lang-r">ggplot(data = mpg) +  geom_point(mapping = aes(x = displ, y = hwy)) -> pp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img data-src="/figure_rdata_science/unnamed-chunk-2-1.png" title="plot of chunk unnamed-chunk-2" alt="plot of chunk unnamed-chunk-2" style="display:block;margin:auto"></p><p>其中<code>mapping</code>是映射的意思，在<code>ggplot()</code>的<code>()</code>中出现的内容将传递之后的绘图函数，<code>p</code>保存了绘制好的图形，可以进一步进行美化和调整：</p><pre class="line-numbers language-lang-r"><code class="language-lang-r">p + theme_minimal(base_family = enfont) +      theme(axis.text.x = element_blank(),            axis.text.y = element_blank(),            axis.title = element_text(size = 12))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img data-src="/figure_rdata_science/unnamed-chunk-3-1.png" title="plot of chunk unnamed-chunk-3" alt="plot of chunk unnamed-chunk-3" style="display:block;margin:auto"><br>可以将一些图片调整的代码存放在<code>modify</code>命名的一个对象中：</p><pre class="line-numbers language-lang-r"><code class="language-lang-r">theme_minimal(base_family = enfont) +  theme(axis.text.x = element_blank(),        axis.text.y = element_blank(),        axis.title = element_text(size = 12)) -> modify<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>实际上，<code>ggplot2</code>的魅力之一在于通过颜色(<strong>color</strong>)、形状(<strong>shape</strong>)、透明度(<strong>alpha</strong>)等等属性展示超越<strong>2</strong>维的信息，比如：</p><pre class="line-numbers language-lang-r"><code class="language-lang-r">ggplot(data = mpg) +  geom_point(mapping = aes(x = displ, y = hwy, color = class)) +  modify<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img data-src="/figure_rdata_science/unnamed-chunk-5-1.png" title="plot of chunk unnamed-chunk-5" alt="plot of chunk unnamed-chunk-5" style="display:block;margin:auto"></p><p>另外一种展示超越2维属性的方法就是<strong>分面</strong>：</p><pre class="line-numbers language-lang-r"><code class="language-lang-r">ggplot(data = mpg) +  geom_point(mapping = aes(x = displ, y = hwy)) +  facet_wrap(~ class, nrow = 2) +  modify<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img data-src="/figure_rdata_science/unnamed-chunk-6-1.png" title="plot of chunk unnamed-chunk-6" alt="plot of chunk unnamed-chunk-6" style="display:block;margin:auto"></p><p><code>facet_wrap()</code>中的第一个参数是<strong>R</strong>中的一种数据结构，叫作“公式”，并非数学意义上的意思。也可以使用2个变量进行分面：</p><pre class="line-numbers language-lang-r"><code class="language-lang-r">ggplot(data = mpg) +  geom_point(mapping = aes(x = displ, y = hwy, color = class)) +  facet_wrap(drv ~ cyl, nrow = 2) +  modify<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img data-src="/figure_rdata_science/unnamed-chunk-7-1.png" title="plot of chunk unnamed-chunk-7" alt="plot of chunk unnamed-chunk-7" style="display:block;margin:auto"></p><p>可以使用占位符<code>.</code>来代替<code>facet_wrap()</code>第一个参数中的<code>drv</code>，效果如下：</p><pre class="line-numbers language-lang-r"><code class="language-lang-r">ggplot(data = mpg) +  geom_point(mapping = aes(x = displ, y = hwy, color = class)) +  facet_wrap(. ~ cyl, nrow = 2) +  modify<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img data-src="/figure_rdata_science/unnamed-chunk-8-1.png" title="plot of chunk unnamed-chunk-8" alt="plot of chunk unnamed-chunk-8" style="display:block;margin:auto"></p><h2 id="几何对象"><a href="#几何对象" class="headerlink" title="几何对象"></a>几何对象</h2><p>R并非只有<code>ggplot2</code>一种绘图方案，比如：</p><pre class="line-numbers language-lang-r"><code class="language-lang-r">set.seed(123)n <- 1000x1  <- matrix(rnorm(n), ncol = 2)x2  <- matrix(rnorm(n, mean = 3, sd = 1.5), ncol = 2)x   <- rbind(x1, x2)head(x)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>#&gt;             [,1]        [,2]#&gt; [1,] -0.56047565 -0.60189285#&gt; [2,] -0.23017749 -0.99369859#&gt; [3,]  1.55870831  1.02678506#&gt; [4,]  0.07050839  0.75106130#&gt; [5,]  0.12928774 -1.50916654#&gt; [6,]  1.71506499 -0.09514745</code></pre><pre class="line-numbers language-lang-r"><code class="language-lang-r">smoothScatter(x, xlab = "x1", ylab = "x2")<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img data-src="/figure_rdata_science/unnamed-chunk-9-1.png" title="plot of chunk unnamed-chunk-9" alt="plot of chunk unnamed-chunk-9" style="display:block;margin:auto"></p><p>而ggplot2肯定并非只有一类几何对象，比如<code>geom_smooth</code>、<code>geom_line</code>、<code>geom_bar</code>等等，而这些对象生成的图层可以堆叠，比如：</p><pre class="line-numbers language-lang-r"><code class="language-lang-r">ggplot(data = mpg) +  geom_point(mapping = aes(x = displ, y = hwy, color = drv),             show.legend = FALSE) +  geom_smooth(mapping = aes(x = displ, y = hwy, linetype = drv),              show.legend = FALSE)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img data-src="/figure_rdata_science/unnamed-chunk-10-1.png" title="plot of chunk unnamed-chunk-10" alt="plot of chunk unnamed-chunk-10" style="display:block;margin:auto"></p><p><code>geom_smooth()</code>使用单个几何对象表示多行数据(一条曲线)，而<code>geom_bar()</code>和<code>geom_point</code>则是多个几何对象（多个矩形或点），将<code>geom_smooth()</code>的<code>group</code>属性映射为一个离散变量时，这样<code>ggplot2</code>就会为这个分类变量的每个唯一值绘制一个独立的几何对象。</p><pre class="line-numbers language-lang-r"><code class="language-lang-r">ggplot(data = mpg) +  geom_smooth(mapping = aes(x = displ, y = hwy, group = drv) )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img data-src="/figure_rdata_science/unnamed-chunk-11-1.png" title="plot of chunk unnamed-chunk-11" alt="plot of chunk unnamed-chunk-11" style="display:block;margin:auto"></p><p>也可以为不同的图层指定不同的数据:</p><pre class="line-numbers language-lang-r"><code class="language-lang-r">ggplot(data = mpg) +  geom_point(mapping = aes(x = displ, y = hwy, color = drv)) +  geom_smooth(data = dplyr::filter(mpg, class == "subcompact"),              mapping = aes(x = displ, y = hwy),              se = FALSE,              show.legend = FALSE )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img data-src="/figure_rdata_science/unnamed-chunk-12-1.png" title="plot of chunk unnamed-chunk-12" alt="plot of chunk unnamed-chunk-12" style="display:block;margin:auto"></p><h2 id="统计变换"><a href="#统计变换" class="headerlink" title="统计变换"></a>统计变换</h2><p><code>geom_bar()</code>函数可以绘制的基本条形图。</p><pre class="line-numbers language-lang-r"><code class="language-lang-r">ggplot(data = diamonds) +  geom_bar(mapping = aes(x = cut))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img data-src="/figure_rdata_science/unnamed-chunk-13-1.png" title="plot of chunk unnamed-chunk-13" alt="plot of chunk unnamed-chunk-13" style="display:block;margin:auto"></p><p>条形图<br><code>x</code><br>轴显示的是<br><code>cut</code><br>，这是<br><code>diamonds</code><br>数据集中的一个变量。<br><code>y</code><br>轴显示的是<br><code>count</code><br>，但<br><code>count</code><br>不是<br><code>diamonds</code><br>中的变量！<br><code>count</code><br>来自哪里呢？很多图形绘制的是数据集的原始数据，比如散点图。另外一些图形则可以绘制那些计算出的新数据，比如条形图。</p><p>绘图时用来计算新数据的算法称为stat（statistical transformation），即统计变换。你可能想要覆盖默认的统计变换。在以下代码中，我们将<code>geom_bar()</code>函数的统计变换从计数（默认值）修改为标识。这样我们就可以将条形的高度映射为<code>y</code>轴变量的初始值。遗憾的是，当随意说起条形图时，人们指的可能就是这种条形图，其中条形高度已经存在于数据中，而不是像前一个图一样，条形高度由对行进行计数来生成：</p><pre class="line-numbers language-lang-r"><code class="language-lang-r">demo <- tribble(  ~a,      ~b,  "bar_1", 20,  "bar_2", 30,  "bar_3", 40)ggplot(data = demo) +  geom_bar(    mapping = aes(x = a, y = b), stat = "identity"  )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img data-src="/figure_rdata_science/unnamed-chunk-14-1.png" title="plot of chunk unnamed-chunk-14" alt="plot of chunk unnamed-chunk-14" style="display:block;margin:auto"></p><p>也可以改变统计变换的默认映射：</p><pre class="line-numbers language-lang-r"><code class="language-lang-r">ggplot(data = diamonds) +  geom_bar(    mapping = aes(x = cut, y = ..prop.., group = 1)  )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img data-src="/figure_rdata_science/unnamed-chunk-15-1.png" title="plot of chunk unnamed-chunk-15" alt="plot of chunk unnamed-chunk-15" style="display:block;margin:auto"></p><p>你可能想要在代码中强调统计变换。例如，你可以使用<code>stat_summary()</code>函数将人们的注意力吸引到你计算出的那些摘要统计量上。<code>stat_summary()</code>函数为<code>x</code>的每个唯一值计算<code>y</code>值的摘要统计：</p><pre class="line-numbers language-lang-r"><code class="language-lang-r">ggplot(data = diamonds) +  stat_summary(    mapping = aes(x = cut, y = depth),        fun.ymin = min,    fun.ymax = max,    fun.y = median  )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img data-src="/figure_rdata_science/unnamed-chunk-16-1.png" title="plot of chunk unnamed-chunk-16" alt="plot of chunk unnamed-chunk-16" style="display:block;margin:auto"></p><p><code>ggplot2</code>提供了20多个统计变换以供你使用。每个统计变换都是一个函数，因此你可以按照通用方式获得帮助，例如<code>?stat_bin</code></p>]]></content>
      
      
      <categories>
          
          <category> 绘图 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> R </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>致Berry</title>
      <link href="/2020/05/25/berry/"/>
      <url>/2020/05/25/berry/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><hr><center>**Love You.**</center><center>**Berry!**</center><center><img data-src="/image/berry.jpg" width="66%" height="66%" title="妳" alt="妳"></center>]]></content>
      
      
      <categories>
          
          <category> 领导 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 妳 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何在双变量Probit中使用工具变量法IV估计</title>
      <link href="/2020/05/25/biprobit_iv/"/>
      <url>/2020/05/25/biprobit_iv/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><hr><h1 id="ML两步法"><a href="#ML两步法" class="headerlink" title="ML两步法"></a>ML两步法</h1><p>可以采用二步法进行ML估计，以下将会以一段样例代码展示：</p><pre class="line-numbers language-lang-stata"><code class="language-lang-stata">webuse school, clearset seed 1capture program drop mybiprobitprogram mybiprobitargs lnf m1   m2  athrho  zb1 lns1tempvar rhoqui:gen double `rho'=tanh(`athrho')qui:replace `lnf'=ln(normalden($ML_y3,`zb1',exp(`lns1')))qui:replace `lnf'=`lnf'+ln(binormal(`m1',`m2',`rho')) if $ML_y1==1 & $ML_y2==1qui:replace `lnf'=`lnf'+ln(binormal(`m1',-`m2',-`rho')) if $ML_y1==1 & $ML_y2==0qui:replace `lnf'=`lnf'+ln(binormal(-`m1',`m2',-`rho')) if $ML_y1==0 & $ML_y2==1qui:replace `lnf'=`lnf'+ln(binormal(-`m1',-`m2',`rho')) if $ML_y1==0 & $ML_y2==0end**Here I am creating an artificial IVgen z=logptax-rnormal()ml model lf mybiprobit (private:private=logptax loginc years)   (vote:vote=logptax loginc years)   /athrho (zb1:logptax=loginc  years z) /lns1ml maximize,matrix b=e(b)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><a id="more"></a><pre class="line-numbers language-lang-stata"><code class="language-lang-stata">capture program drop mybiprobitivprogram mybiprobitivargs lnf mm1 g1  mm2  g2 athrho  zb1 lns1tempvar rhoqui:gen double `rho'=tanh(`athrho')qui:replace `lnf'=ln(normalden($ML_y3,`zb1',exp(`lns1')))tempvar m1 m2qui:gen double `m1'=`mm1'+`g1'*($ML_y3-`zb1')qui:gen double `m2'=`mm2'+`g2'*($ML_y3-`zb1')qui:replace `lnf'=`lnf'+ln(binormal(`m1',`m2',`rho')) if $ML_y1==1 & $ML_y2==1qui:replace `lnf'=`lnf'+ln(binormal(`m1',-`m2',-`rho')) if $ML_y1==1 & $ML_y2==0qui:replace `lnf'=`lnf'+ln(binormal(-`m1',`m2',-`rho')) if $ML_y1==0 & $ML_y2==1qui:replace `lnf'=`lnf'+ln(binormal(-`m1',-`m2',`rho')) if $ML_y1==0 & $ML_y2==0endml model lf mybiprobitiv (private:private=logptax loginc years) (g1:)  (vote:vote=logptax loginc years)  (g2:) /athrho (zb1:logptax=loginc  years z  ) /lns1, init(b)ml maximize<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 计量 </category>
          
          <category> 内生性问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> stata </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shell脚本笔记（1）</title>
      <link href="/2020/05/25/shell_1/"/>
      <url>/2020/05/25/shell_1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><hr><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>shell是用C语言编写的程序，但它自身同时也是一种程序设计语言。你可能经常听说“shell脚本”，但实际上shell编程并非等同于“shell脚本”编程，前者指shell程序本身的开发，后者则是利用shell程序进行开发。都说java和javascript的区别是周杰和周杰伦的区别，shell和shell script或许也有那么点意思。</p><h1 id="shell脚本"><a href="#shell脚本" class="headerlink" title="shell脚本"></a>shell脚本</h1><p>似乎任何程序学习都是从”Hello World!”开始的，对于<strong>shell</strong>而言：</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">#!/bin/bashecho "Hello World !"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>#!</strong>是个标记，告知这段命令将用bash执行。echo则是一个向窗口展示文本的命令。<br>你可以将以上代码框的内容存为一个以.sh为后缀的文件，比如<strong>hw.sh</strong>，并赋予文件执行权限：</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">chmod +x ./hw.sh         #赋予执行权限bash hw.sh               #执行脚本<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><a id="more"></a><p>未完待续</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
